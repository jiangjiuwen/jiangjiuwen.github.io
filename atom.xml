<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiuwen&#39;s Blog</title>
  
  <subtitle>.NET &amp; Python Developer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jiangjiuwen.com/"/>
  <updated>2018-05-04T09:22:51.109Z</updated>
  <id>http://jiangjiuwen.com/</id>
  
  <author>
    <name>Jiang Jiuwen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>杭州·灵隐寺</title>
    <link href="http://jiangjiuwen.com/%E6%B8%B8%E8%AE%B0/lingyin-temple/"/>
    <id>http://jiangjiuwen.com/游记/lingyin-temple/</id>
    <published>2018-05-04T08:43:05.000Z</published>
    <updated>2018-05-04T09:22:51.109Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">杭州 · 灵隐寺</blockquote><br><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/lingyin-temple20180504165349.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/lingyin-temple20180504165215.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/lingyin-temple20180504165358.jpg" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/lingyin-temple20180504165320.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/lingyin-temple20180504165408.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/lingyin-temple20180504165225.jpg" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/lingyin-temple20180504165302.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/lingyin-temple20180504165338.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/lingyin-temple20180504165247.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;杭州 · 灵隐寺&lt;/blockquote&gt;&lt;br&gt;&lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class
      
    
    </summary>
    
      <category term="游记" scheme="http://jiangjiuwen.com/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="旅游" scheme="http://jiangjiuwen.com/tags/%E6%97%85%E6%B8%B8/"/>
    
      <category term="杭州" scheme="http://jiangjiuwen.com/tags/%E6%9D%AD%E5%B7%9E/"/>
    
      <category term="灵隐寺" scheme="http://jiangjiuwen.com/tags/%E7%81%B5%E9%9A%90%E5%AF%BA/"/>
    
  </entry>
  
  <entry>
    <title>双线性插值算法</title>
    <link href="http://jiangjiuwen.com/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/bilinear-interpolation/"/>
    <id>http://jiangjiuwen.com/编程之美/bilinear-interpolation/</id>
    <published>2018-04-20T11:49:36.000Z</published>
    <updated>2018-04-20T13:41:47.794Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间项目上为了减小图像体积，比如将一个512 * 512的图像插值到100 * 100，用到了双线性插值算法，今天记录一下。</p><p>主要包括两个步骤：矩阵映射和插值计算</p><h1 id="矩阵映射"><a href="#矩阵映射" class="headerlink" title="矩阵映射"></a>矩阵映射</h1><p>要将一个(x, y)的矩阵比如512 * 512转换成(x’, y’)的矩阵比如100 * 100，则其缩放比为(x/x’, y/y’)</p><p>那么转换后的矩阵中的点(m, n)映射到原始矩阵中的点为(m * x/x’, n * y/y’)</p><p>比如，转换矩阵中的点(1, 1)则对应原始矩阵中的点(5.12, 5.12)，但是坐标点都是整数，原始矩阵中没有与之对应的像素点，那么就需要使用改点邻近的四个像素点进行计算，得到一个像素值。</p><h1 id="插值计算"><a href="#插值计算" class="headerlink" title="插值计算"></a>插值计算</h1><p>下图是在网上找的一个插值计算的示意图。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e7/Bilinear_interpolation.png" alt=""></p><p>所谓的双线性插值实际上使用了三次线性插值，首先利用点Q12和点Q22进行插值计算得到点R2的值，然后利用点Q11和Q21点进行插值计算得到点R1的值，最后利用得到点R1和点R2进行插值从而得到点P的值。</p><p>线性插值的过程为(R2 - Q12) / (Q22 - R2) = (x - x1) / (x2 - x)</p><p>如果Q12 Q22 Q11 Q21的像素值分别为200, 150, 100, 50，那么首先计算出R2的值为194，然后计算出R1的值为94，然后根据R1和R2计算出P点的像素值为182，所以经过插值计算后，映射之后的点(1, 1)的像素值为182。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间项目上为了减小图像体积，比如将一个512 * 512的图像插值到100 * 100，用到了双线性插值算法，今天记录一下。&lt;/p&gt;
&lt;p&gt;主要包括两个步骤：矩阵映射和插值计算&lt;/p&gt;
&lt;h1 id=&quot;矩阵映射&quot;&gt;&lt;a href=&quot;#矩阵映射&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="编程之美" scheme="http://jiangjiuwen.com/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="插值算法" scheme="http://jiangjiuwen.com/tags/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/"/>
    
      <category term="图像处理" scheme="http://jiangjiuwen.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>在Ubuntu系统中使用不同版本的Python环境</title>
    <link href="http://jiangjiuwen.com/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/virtual-environment-of-python/"/>
    <id>http://jiangjiuwen.com/编程之美/virtual-environment-of-python/</id>
    <published>2018-03-21T10:47:00.000Z</published>
    <updated>2018-04-01T09:00:23.793Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu16.4版本中默认包含python2.7和Python3.5两个版本，命令行中可以分别使用python和python3来启动并进入各自环境。</p><p>virtualenv用于创建独立的Python环境，使得多个Python相互隔离，互不影响，它能够：</p><ul><li>在没有权限的情况下安装python包</li><li>不同应用可以使用不同版本的python包</li><li>一个环境下的python包升级不影响其他环境</li></ul><p>顾名思义，virtualenvwrapper则是对虚拟环境进行管理，是virtualenv的扩展包，它能够：</p><ul><li>将所有虚拟环境整合在一个目录下</li><li>管理（新增，删除，复制）虚拟环境</li><li>切换虚拟环境</li></ul><h1 id="安装virtualenvwrapper"><a href="#安装virtualenvwrapper" class="headerlink" title="安装virtualenvwrapper"></a>安装virtualenvwrapper</h1><p>对于一台全新的Ubuntu电脑，可能还需要首先安装pip，即python包管理器，命令如下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pip  <span class="comment"># 对应python2</span></span><br><span class="line">sudo apt-get install python3-pip  <span class="comment"># 对应python3</span></span><br></pre></td></tr></table></figure></p><p>之后使用pip安装virtualenvwrapper。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install virtualenvwrapper</span><br></pre></td></tr></table></figure></p><p>注意，系统默认采用python2，所以，如果使用pip3进行安装，之后会报错，此处按下不表。</p><h1 id="配置virtualenvwrapper"><a href="#配置virtualenvwrapper" class="headerlink" title="配置virtualenvwrapper"></a>配置virtualenvwrapper</h1><p>virtualenvwrapper安装完成之后需要对其进行简单配置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="variable">$HOME</span>/.venvs</span><br><span class="line">sudo vim ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在打开的.bashrc文件中添加如下2行：</span></span><br><span class="line"><span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.venvs</span><br><span class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure></p><p>如果virtualenvwrapper是使用pip3进行安装，则会报如下错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/python: No module named virtualenvwrapper</span><br><span class="line">virtualenvwrapper.sh: There was a problem running the initialization hooks.</span><br><span class="line"></span><br><span class="line">If Python could not import the module virtualenvwrapper.hook_loader,</span><br><span class="line">check that virtualenvwrapper has been installed <span class="keyword">for</span></span><br><span class="line">VIRTUALENVWRAPPER_PYTHON=/usr/bin/python and that PATH is</span><br><span class="line"><span class="built_in">set</span> properly.</span><br></pre></td></tr></table></figure><p>至此，virtualenvwrapper的安装和配置告一段落。</p><h1 id="使用virtualenvwrapper管理虚拟环境"><a href="#使用virtualenvwrapper管理虚拟环境" class="headerlink" title="使用virtualenvwrapper管理虚拟环境"></a>使用virtualenvwrapper管理虚拟环境</h1><p>基于不同的python版本创建虚拟环境<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv -p /usr/bin/python2 scrapy_py2  <span class="comment"># 创建基于python2的虚拟环境scrapy_py2</span></span><br><span class="line">mkvirtualenv -p /usr/bin/python3 scrapy_py3  <span class="comment"># 创建基于python3虚拟环境scrapy_py3</span></span><br><span class="line"><span class="comment"># 如果提示mkvirtualenv权限问题，请检查$HOME/.venvs文件所属的用户和组。</span></span><br></pre></td></tr></table></figure></p><p>创建成功之后系统默认进入当前虚拟环境，命令行前缀显示当前虚拟环境名称。进入虚拟环境之后所有的操作都基于当前python环境，不会对其他python环境产生影响。</p><p>其他命令如下所示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">workon  <span class="comment"># 列出所有的虚拟环境</span></span><br><span class="line">workon scrapy_py2  <span class="comment"># 切换到虚拟环境scrapy_py2</span></span><br><span class="line">deactivate  <span class="comment"># 退出当前虚拟环境</span></span><br><span class="line">rmvirtualenv scrapy_py2  <span class="comment"># 删除虚拟环境scrapy_py2</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ubuntu16.4版本中默认包含python2.7和Python3.5两个版本，命令行中可以分别使用python和python3来启动并进入各自环境。&lt;/p&gt;
&lt;p&gt;virtualenv用于创建独立的Python环境，使得多个Python相互隔离，互不影响，它能够：&lt;/p
      
    
    </summary>
    
      <category term="编程之美" scheme="http://jiangjiuwen.com/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="Python" scheme="http://jiangjiuwen.com/tags/Python/"/>
    
      <category term="Ubuntu" scheme="http://jiangjiuwen.com/tags/Ubuntu/"/>
    
      <category term="virtualenvwrapper" scheme="http://jiangjiuwen.com/tags/virtualenvwrapper/"/>
    
  </entry>
  
  <entry>
    <title>Python的几种导入操作</title>
    <link href="http://jiangjiuwen.com/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/the-import-operations-in-python/"/>
    <id>http://jiangjiuwen.com/编程之美/the-import-operations-in-python/</id>
    <published>2018-03-16T14:10:41.000Z</published>
    <updated>2018-04-01T09:00:23.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块-Module-和包-Package"><a href="#模块-Module-和包-Package" class="headerlink" title="模块(Module)和包(Package)"></a>模块(Module)和包(Package)</h1><p>Python中一个源文件就是一个模块，即一个py文件就是一个模块，模块中可能包含字段、函数、类等定义，也可能什么都没有，即一个空的模块。</p><p>Python包就是一个管理着一个或者一些模块的文件夹，其中有一个特殊的模块，即<code>__init__.py</code>，当加载一个包的时候，包中的<code>__init__.py</code>模块将被首先执行。包可以嵌套包含，即一个包下面还包含这一些子包。</p><p>以下就是一个常见的包结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package/</span><br><span class="line">    __init__.py</span><br><span class="line">    moduleA.py</span><br><span class="line">    moduleB.py</span><br><span class="line">    subPackage/</span><br><span class="line">        __init__.py</span><br><span class="line">        subModuleA.py</span><br><span class="line">        subModuleB.py</span><br></pre></td></tr></table></figure><h1 id="几种import方式"><a href="#几种import方式" class="headerlink" title="几种import方式"></a>几种import方式</h1><p>以上面的包结构为例，假设包中没有<code>__init__.py</code>模块，<code>subPackage</code>包中的<code>subModuleA.py</code>模块的代码如下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># subModuleA.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subModuleFun</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello from subModuleFun'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subModuleFunTwo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello from subModuleFunTwo'</span>)</span><br></pre></td></tr></table></figure></p><p>那么<code>package</code>包中的<code>moduleA.py</code>可以通过以下几种方式调用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># moduleA.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 按照绝对路径导入subModuleA</span></span><br><span class="line"><span class="keyword">import</span> subPackage.subModuleA</span><br><span class="line">subPackage.subModuleA.subModuleFun() <span class="comment"># Hello from subModuleFun</span></span><br><span class="line">subPackage.subModuleA.subModuleFunTwo() <span class="comment"># Hello from subModuleFunTwo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 为导入指定别名</span></span><br><span class="line"><span class="keyword">import</span> subPackage.subModuleA <span class="keyword">as</span> sma</span><br><span class="line">sma.subModuleFun() <span class="comment"># Hello from subModuleFun</span></span><br><span class="line">sma.subModuleFunTwo() <span class="comment"># Hello from subModuleFunTwo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 按需导入，即只导入需要调用的内容</span></span><br><span class="line"><span class="keyword">from</span> subPackage.subModuleA <span class="keyword">import</span> subModuleFun</span><br><span class="line">subModuleFun() <span class="comment"># Hello from subModuleFun</span></span><br><span class="line">subModuleFunTwo() <span class="comment"># Error</span></span><br><span class="line">subPackage.subModuleA.subModuleFunTwo() <span class="comment"># Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 导入模块中所有内容</span></span><br><span class="line"><span class="keyword">from</span> subPackage.subModuleA <span class="keyword">import</span> *</span><br><span class="line">subModuleFun() <span class="comment"># Hello from subModuleFun</span></span><br><span class="line">subModuleFunTwo() <span class="comment"># Hello from subModuleFunTwo</span></span><br></pre></td></tr></table></figure></p><h1 id="init-py模块的作用"><a href="#init-py模块的作用" class="headerlink" title="__init__.py模块的作用"></a><code>__init__.py</code>模块的作用</h1><p>仍然以上面的包结构为例，包中有<code>__init__.py</code>模块，且<code>__init__.py</code>模块的代码如下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># package/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> moduleA <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> moduleB <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># package/subPackage/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> subModuleA <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> subModuleB <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># moduleA.py调用subPackage.subModuleA中的subModuleFun方法</span></span><br><span class="line"><span class="keyword">from</span> subPackage <span class="keyword">import</span> subModuleFun</span><br><span class="line">subModuleFun() <span class="comment"># Hello from subModuleFun</span></span><br></pre></td></tr></table></figure></p><p>由此可见，此时我如果想从某个包里面调用某个模块中的某个函数时就可以直接从包里面导入，而不需要指定该函数所在模块的路径。从而带来两个好处，一个是简化了import路径，二是便于开发者控制各个模块或方法的访问级别。</p><h1 id="import的作用域"><a href="#import的作用域" class="headerlink" title="import的作用域"></a>import的作用域</h1><p>如果在模块的最顶端进行导入，则其作用域为整个模块，表示整个模块的内容都能访问导入的内容。</p><p>如果仅在某个代码块中进行导入，则其作用域为该代码块。如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> globalModule</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcA</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> subModule</span><br><span class="line">    globalModule.func()</span><br><span class="line">    subModule.func()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcB</span><span class="params">()</span>:</span></span><br><span class="line">    globalModule.func()</span><br><span class="line">    subModule.func() <span class="comment"># Error</span></span><br><span class="line"></span><br><span class="line">globalModule.func()</span><br></pre></td></tr></table></figure><h1 id="循环导入"><a href="#循环导入" class="headerlink" title="循环导入"></a>循环导入</h1><p>循环导入即A模块导入B模块，同时B模块中又导入了A模块，此时运行任意一个模块都将收到<code>AttributeError</code>的报错。</p><p>如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A.py</span></span><br><span class="line"><span class="keyword">import</span> B</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcA</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'funcA'</span>)</span><br><span class="line"></span><br><span class="line">funcA()</span><br><span class="line">B.funcB()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># B.py</span></span><br><span class="line"><span class="keyword">import</span> A</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcB</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'funcB'</span>)</span><br><span class="line"></span><br><span class="line">funcB()</span><br><span class="line">A.funcA()</span><br></pre></td></tr></table></figure><h1 id="导入和标准模块重名的模块"><a href="#导入和标准模块重名的模块" class="headerlink" title="导入和标准模块重名的模块"></a>导入和标准模块重名的模块</h1><p>当我们自定义的模块名称和标准库中的模块名称重复的时候，导入就有可能会发生混乱，此时在调用标准库中的函数时，编译器可能会报错该方法不存在，不过在高版本的python中好像会自动到标准库中寻找该方法。不过，为了保证代码的正确性和可读性，不建议自定义的模块和标准库模块重名。</p><h1 id="相对路径导入"><a href="#相对路径导入" class="headerlink" title="相对路径导入"></a>相对路径导入</h1><p>如果子包中的模块想要访问上级包中的内容，则可以使用相对路径导入。</p><p><strong>注意，此时正在导入的模块的<code>__name__</code>不能是<code>__main__</code>，即此时执行的主函数不在当前正在导入的模块中。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># subModuleA.py</span></span><br><span class="line"><span class="keyword">from</span> ..moduleA <span class="keyword">import</span> moduleFun <span class="comment"># 一个.表示一级目录</span></span><br><span class="line">moduleFun()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模块-Module-和包-Package&quot;&gt;&lt;a href=&quot;#模块-Module-和包-Package&quot; class=&quot;headerlink&quot; title=&quot;模块(Module)和包(Package)&quot;&gt;&lt;/a&gt;模块(Module)和包(Package)&lt;/h1
      
    
    </summary>
    
      <category term="编程之美" scheme="http://jiangjiuwen.com/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="Python" scheme="http://jiangjiuwen.com/tags/Python/"/>
    
      <category term="import" scheme="http://jiangjiuwen.com/tags/import/"/>
    
  </entry>
  
  <entry>
    <title>collections模块常用数据结构</title>
    <link href="http://jiangjiuwen.com/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/overview-of-collections-module/"/>
    <id>http://jiangjiuwen.com/编程之美/overview-of-collections-module/</id>
    <published>2018-03-10T05:57:08.000Z</published>
    <updated>2018-04-01T09:00:23.792Z</updated>
    
    <content type="html"><![CDATA[<p>collections模块是python自带的模块，为开发者提供了很多方便且高效的数据结构，帮助开发者写出简单高效且可读性高的python代码。</p><h1 id="collections模块常用数据结构"><a href="#collections模块常用数据结构" class="headerlink" title="collections模块常用数据结构"></a>collections模块常用数据结构</h1><p>collections模块中最常被使用的数据结构主要包括deque、defaultdict、namedtuple、Counter、OrderedDict、ChainMap这6个，如下表所示。</p><table><thead><tr><th style="text-align:center">名称</th><th>定义</th></tr></thead><tbody><tr><td style="text-align:center">deque</td><td>双端队列</td></tr><tr><td style="text-align:center">defaultdict</td><td>具有默认值的字典类型</td></tr><tr><td style="text-align:center">namedtuple</td><td>具有类的特性的tuple类型</td></tr><tr><td style="text-align:center">Counter</td><td>具有计数功能的字典类型</td></tr><tr><td style="text-align:center">OrderedDict</td><td>按添加顺序排列的字典类型</td></tr><tr><td style="text-align:center">ChainMap</td><td>将多个字典链接为一个字典</td></tr></tbody></table><h1 id="tuple和namedtuple"><a href="#tuple和namedtuple" class="headerlink" title="tuple和namedtuple"></a>tuple和namedtuple</h1><p>tuple特点：</p><ul><li>不可变（不完全不可变，比如某个item为list或其他可变类型时，其值就可变，不推荐这种做法）</li><li>可遍历</li><li>可拆包</li><li>可哈希（使其可以作为字典的key）</li><li>线程安全</li></ul><p>tuple的item不像字典一样有key对应，为了使tuple可以像类一样通过指定字段名称来调用tuple的值，于是就有了namedtuple。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User = namedtuple(<span class="string">"User"</span>, (<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'height'</span>))</span><br><span class="line">fields = (<span class="string">'jim'</span>, <span class="number">22</span>, <span class="number">176</span>)</span><br><span class="line">user = User(*fields)</span><br><span class="line">name, *other = user <span class="comment"># 拆包</span></span><br><span class="line">print(name, other)</span><br></pre></td></tr></table></figure><p>namedtuple特点：</p><ul><li>节省空间。不会生成不必要的类字段</li><li>代码简洁、美观。少量的代码即能实现类和tuple的特性</li></ul><h1 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h1><p>通常当我们操作的索引不在字典当前字典中时，编译器会报错，此时就要通过if else之类的语句进行判断该索引是否在字典中，然后再进行处理，通常这样做效率不高而且代码不优雅。而defaultdict就可以定义一个默认值，当操作不存在的索引时，就会给该索引赋予默认值，然后再进行后续操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default_dict = defaultdict(int)</span><br><span class="line">default_dict[<span class="string">'age'</span>] += <span class="number">22</span></span><br></pre></td></tr></table></figure><h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><p>deque具有list相似的特性，但也有一些区别。</p><ul><li>不同的是list默认函数只能对list对尾进行操作，而deque对对头和队尾都可以操作</li><li>deque是线程安全的，而list不是</li></ul><p>另外，python3中的queue就是用deque来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name_deque = deque([<span class="string">'jim'</span>, <span class="string">'jack'</span>, <span class="string">'tony'</span>])</span><br><span class="line">name_deque.appendleft(<span class="string">'lily'</span>)</span><br><span class="line">name_deque.reverse()</span><br></pre></td></tr></table></figure><h1 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h1><p>Counter可以统计任意可迭代的类型，比如list、tuple、dict、string等。Counter中比较重要的函数有update和most_comon。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">counter1 = Counter(<span class="string">'dsagwdsdagwecsada'</span>)</span><br><span class="line">print(counter1)</span><br><span class="line">counter2 = Counter(&#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>, <span class="string">'k2'</span>:<span class="string">'v2'</span>, <span class="string">'k3'</span>:<span class="string">'v1'</span>&#125;)</span><br><span class="line">print(counter2)</span><br><span class="line">counter3 = Counter(<span class="string">'ggggggg'</span>)</span><br><span class="line">counter1.update(counter3)</span><br><span class="line">print(counter1)</span><br></pre></td></tr></table></figure><h1 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h1><p>顾名思义，OrderedDict就是用来表征已经排好序的字典，由于字典具有无序性，即字典中的key的位置是不固定的，而OrderedDict中的键值对则是按照添加时间按序排列的,即保证了时序性，又有dict的方便性。</p><p>值得注意的是，在python3中，dict默认是有序的，在python2中不是，但是OrderedDict中包含了一些dict没有的方法，比如clear，所以在python3中还是有必要使用OrderedDict的。</p><h1 id="ChainMap"><a href="#ChainMap" class="headerlink" title="ChainMap"></a>ChainMap</h1><p>当我们需要遍历多个字典的时候，需要写大量重复代码，这个时候ChainMap就能将多个字典链接起来，使其看起来像是一个字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">users1 = &#123;<span class="string">'a'</span>:<span class="string">'jack'</span>, <span class="string">'b'</span>:<span class="string">'lily'</span>&#125;</span><br><span class="line">users2 = &#123;<span class="string">'b'</span>:<span class="string">'tony'</span>, <span class="string">'d'</span>:<span class="string">'jason'</span>&#125;</span><br><span class="line">users = ChainMap(users1, users2)</span><br><span class="line">print(users)</span><br><span class="line">print(users.popitem(), users)</span><br><span class="line">print(users.maps)</span><br></pre></td></tr></table></figure><p>值得注意的是，如果不同的字典中具有相同的key，则只操作第一个key，后面出现相同的key时会将其忽略</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>python内置的基本类型已经具有非常丰富的功能，而以上数据类型作为基本类型的升级版不仅增强了性能，保证编写的代码更健壮，而且使代码编写更方便，写出来的代码更优雅。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;collections模块是python自带的模块，为开发者提供了很多方便且高效的数据结构，帮助开发者写出简单高效且可读性高的python代码。&lt;/p&gt;
&lt;h1 id=&quot;collections模块常用数据结构&quot;&gt;&lt;a href=&quot;#collections模块常用数据结构&quot; 
      
    
    </summary>
    
      <category term="编程之美" scheme="http://jiangjiuwen.com/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="Python" scheme="http://jiangjiuwen.com/tags/Python/"/>
    
      <category term="Collections" scheme="http://jiangjiuwen.com/tags/Collections/"/>
    
      <category term="数据结构" scheme="http://jiangjiuwen.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>人生就是连续不断的选择题</title>
    <link href="http://jiangjiuwen.com/%E9%9A%8F%E7%AC%94/a-or-b/"/>
    <id>http://jiangjiuwen.com/随笔/a-or-b/</id>
    <published>2017-12-02T11:07:51.000Z</published>
    <updated>2018-04-01T09:00:23.791Z</updated>
    
    <content type="html"><![CDATA[<p>前几天收到域名即将过期的提醒，于是赶紧续费了两年，才发现好久没写博客了，记录一下目前的生活吧。</p><p>前段时间其实一直在找工作，打算跳槽到杭州，可能是还不习惯武汉的生活，也许是对现在的工作感到无趣，准备转行大数据，做Python开发，可是几乎收不到面试，难得收到网易和阿里的电话面试，也在第一轮就挂了，海投了一段时间的Java和Python无果之后决定继续做.NET，虽说面试机会有所增加，选择面却变窄了，因为.NET的行情实在不太好，大厂基本不再使用.NET。虽然拿到几个Offer，不过最终还是因为一些原因拒绝了。</p><p>月初听说最近的股市行情不错，于是在马上开通了股票账户，转了一万块钱进去，算是正式涉足中国股市。证券公司的同学给我推荐了京东方A，据说潜力无限，可以助我发家致富，走向人生巅峰，于是果断重仓之。剩下一点钱打算炒炒短线，可是面对各种走势的股票我却犯了选择困难症，尽管每天都有各路股神对我灌输各类股票的潜规则。调整是必然的，下跌总是会有的，淡定才是王道。</p><p>周三上海的同时来这边出差，于是请他吃了地道了湖北菜，点了巨辣的辣的跳、武昌鱼，本来想点非常好吃的莲藕排骨汤，可惜已经卖完了，于是换成了藕饼，对于吃甜食的口味清淡的上海人来说，面对巨辣的食物果断选择了狗带。很高兴再次见到老同事，吐槽了武汉的环境和现在的工作之余，得知他们的项目越来越规范，我之前参与的项目也越来越稳定，我开始怀疑，当初的选择是否是一时冲动？</p><p>人生就是连续不断的选择题，且不论结果对错，光是做出选择这一举动，就感觉已经拼尽了全力啊… :-(</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几天收到域名即将过期的提醒，于是赶紧续费了两年，才发现好久没写博客了，记录一下目前的生活吧。&lt;/p&gt;
&lt;p&gt;前段时间其实一直在找工作，打算跳槽到杭州，可能是还不习惯武汉的生活，也许是对现在的工作感到无趣，准备转行大数据，做Python开发，可是几乎收不到面试，难得收到网易
      
    
    </summary>
    
      <category term="随笔" scheme="http://jiangjiuwen.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活感悟" scheme="http://jiangjiuwen.com/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC</title>
    <link href="http://jiangjiuwen.com/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/spring-mvc/"/>
    <id>http://jiangjiuwen.com/编程之美/spring-mvc/</id>
    <published>2017-10-08T07:16:24.000Z</published>
    <updated>2018-04-01T09:00:23.790Z</updated>
    
    <content type="html"><![CDATA[<p>Spring是当前比较流行的一种WEB框架，通过实现Model-View-Controller模式来很好地将视图和模型分离。SpringMVC是一个基于DispatcherServlet的MVC框架，每一个请求最先访问的都是DispatcherServlet，DispatcherServlet负责转发每一个Request请求给相应的Handler，Handler处理以后再返回相应的视图(View)和模型(Model)，返回的视图和模型都可以不指定，即可以只返回Model或只返回View或都不返回。</p><h1 id="Spring-MVC模式"><a href="#Spring-MVC模式" class="headerlink" title="Spring MVC模式"></a>Spring MVC模式</h1><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><ul><li>前端发出一个请求。</li><li>DispatcherServlet将该请求转发给相应的控制器。</li><li>控制器对请求进行响应，处理完成之后，控制器会将处理结果委派给一个视图或模型。</li><li>控制器将视图或模型返回给DispatcherServlet，它会根据一个视图解析器将视图的名称解析为一个具体的视图实现。这个视图解析器是一个实现了ViewResolver接口的Bean，它的任务就是返回一个视图的具体实现。</li></ul><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>@Controller：控制器类注解。当控制器类接收到一个请求时，它会在自己内部存照一个合适的方法来处理请求。<br>@RequestMapping：将方法映射到请求上的注解。其实RequestMapping在Class上，可看做是父Request请求url，而RequestMapping在方法上的可看做是子Request请求url，父子请求url最终会拼起来与页面请求url进行匹配。<br>在SpringMVC中常用的注解还有@PathVariable，@RequestParam，@PathVariable标记在方法的参数上，利用它标记的参数可以利用请求路径传值</p><h1 id="Spring-MVC的相关配置"><a href="#Spring-MVC的相关配置" class="headerlink" title="Spring MVC的相关配置"></a>Spring MVC的相关配置</h1><p>SpringMVC是一个基于DispatcherServlet的，首先配置DispatcherServlet，在<code>web.xml</code>中配置DispatcherServlet的name、class以及startup</p><p><code>spring-servlet.xml</code>配置，注意，这个名称是由web.xml中的spring的name标签中的值加上<code>-servlet</code>组成的，前缀是自定义的。这个里面会配置是否启用spring mvc注解、注解的类所用的jar包，跳转页面的路径解析（前缀、后缀等）等内容。</p><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><p>编写拦截器极其简单，只要编写一个类，实现HandlerInterceptor的方法，然后在springMVC的配置文件中配置这个类，就可以使用这个拦截器了。比如权限控制等。</p><p>在使用拦截器时候，并不一定要对所有的目标方法都进行拦截，所以我们可以只对指定的方法进行拦截，这就需要更改配置文件了，只需要在<a href="mvc:interceptors" target="_blank" rel="noopener">mvc:interceptors</a>中配置一个<a href="mvc:interceptor" target="_blank" rel="noopener">mvc:interceptor</a>，然后指定其路径，就可以了，这个路径可以指定一个URL，也可以使用通配符。</p><p>当同时定义了多个拦截器的时候，那么它的使用顺序如下：</p><ul><li>preHandle：当目标方法执行之前，执行此方法，如果返回false，则不会执行目标方法，同样的，后面的拦截器也不会起作用。</li><li>postHandle：执行目标方法之后调用，但是在渲染视图之前，就是转向jsp页面之前，以对请求域中的属性，或者视图进行修改。</li><li>afterCompletion：在渲染视图之后被调用，释放资源。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring是当前比较流行的一种WEB框架，通过实现Model-View-Controller模式来很好地将视图和模型分离。SpringMVC是一个基于DispatcherServlet的MVC框架，每一个请求最先访问的都是DispatcherServlet，Dispatc
      
    
    </summary>
    
      <category term="编程之美" scheme="http://jiangjiuwen.com/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="Spring MVC" scheme="http://jiangjiuwen.com/tags/Spring-MVC/"/>
    
      <category term="JAVA" scheme="http://jiangjiuwen.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>面向对象编程和面向切面编程</title>
    <link href="http://jiangjiuwen.com/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/oop-and-aop/"/>
    <id>http://jiangjiuwen.com/编程之美/oop-and-aop/</id>
    <published>2017-10-08T03:08:55.000Z</published>
    <updated>2018-04-01T09:00:23.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h1><p>面向对象编程是一种程序设计方式，面向对象将所有事物看作具有独立属性和行为的对象。</p><h1 id="面向对象三要素"><a href="#面向对象三要素" class="headerlink" title="面向对象三要素"></a>面向对象三要素</h1><ul><li>封装：把具有相同属性和行为（方法）的对象包装成一个<code>类</code>。封装的意义在于明确表示外部可以访问的属性和行为，有了封装就可以区分内外，可以规定哪些可以访问，哪些不能访问。真正的封装是经过良好的设计，保证最小最细粒度的接口并使得内部实现对外透明，即玩不使用者可以实现自己的功能，但是不知道内部的实现细节。</li><li>继承：一个对象可以从另一个对象获得其属性和行为，并在次基础上扩展自己的属性和行为。其解决了代码重用的问题。</li><li>多态：一个对象在不同的场景下具有不同的表现（实现接口），因为对象访问的类不一样，相同的代码表现的行为可能不一样。</li></ul><h1 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h1><ul><li>单一职责原则(SRP)。一个类只能做一件事情，如果这个类还可以做其他事情，则该类需要被分解。比如一个类用于对用户基本信息进行管理，则该类不能用于用户权限控制。</li><li>开放封闭原则(OCP)。对扩展开发，对修改关闭。为了实现高内聚、低耦合的效果，当新的需求需要被实现的时候，尽可能保证不影响已有功能代码。</li><li>里氏替换原则(LSP)。父类可以出现的地方，子类一定可以出现，即子类可以替换掉父类，且程序功能不受影像。</li><li>接口隔离原则(ISP)。不同类型的接口应该分开实现，而不是一个统一的接口类。</li><li>依赖倒置原则(DCP)。针对接口编程，依赖抽象而不是依赖具体编程。</li></ul><h1 id="面向切面编程-AOP"><a href="#面向切面编程-AOP" class="headerlink" title="面向切面编程(AOP)"></a>面向切面编程(AOP)</h1><p>面向切面编程就是指通过预编译的方式在程序运行时动态地给方法增加一些行为而不改变现有代码。其思想是将很多类共同的行为抽离出来，当这一行为改变时只需要修改该行为，而不需要修改很多类。所以，其优势就在于封装了重复代码，使功能性代码和非功能性代码分离，而且代码看起来更简洁。</p><h1 id="OOP和AOP的关系"><a href="#OOP和AOP的关系" class="headerlink" title="OOP和AOP的关系"></a>OOP和AOP的关系</h1><p>面向切面编程和面向对象编程一样，也是一种编程方式。面向对象关注的是将功能和行为划分成不同的模块，并封装成类。而面向切面编程则是抽取不同的模块中通用的行为，使不同的模块可以共享该行为。所以两者是互补的关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是面向对象&quot;&gt;&lt;a href=&quot;#什么是面向对象&quot; class=&quot;headerlink&quot; title=&quot;什么是面向对象&quot;&gt;&lt;/a&gt;什么是面向对象&lt;/h1&gt;&lt;p&gt;面向对象编程是一种程序设计方式，面向对象将所有事物看作具有独立属性和行为的对象。&lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
      <category term="编程之美" scheme="http://jiangjiuwen.com/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="OOP" scheme="http://jiangjiuwen.com/tags/OOP/"/>
    
      <category term="AOP" scheme="http://jiangjiuwen.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Somethings about Hadoop</title>
    <link href="http://jiangjiuwen.com/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/somethings-about-hadoop/"/>
    <id>http://jiangjiuwen.com/编程之美/somethings-about-hadoop/</id>
    <published>2017-10-03T07:56:12.000Z</published>
    <updated>2018-04-01T09:00:23.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>谷歌大数据技术MapReduce、BigTable、GFS突破了存储容量、读写速率、计算效率的瓶颈，带来了革命性的变化：</p><ul><li>成本降低。能用家用PC计算机。</li><li>软件容错硬件故障视为常态，通过软件保证高可靠性。</li><li>简化并行分布式计算，无须控制节点同步和数据交换。</li></ul><p>但是谷歌只发表了论文，没有公开源码，所以开发者模仿Google大数据技术，创造了一个开源的分布式存储和分布式计算平台<code>Hadoop</code>。</p><p>Hadoop包括两个核心组成：</p><ul><li>HDFS。分布式文件系统，实现海量数据的存储。</li><li>MapReduce。并行处理框架，实现任务的分解和调度。</li></ul><p>Hadoop优势：高扩展、低成本、成熟的生态圈</p><p>常见的Hadoop工具包括：HIVE、HBASE、Zookeeper</p><h1 id="Hadoop的安装"><a href="#Hadoop的安装" class="headerlink" title="Hadoop的安装"></a>Hadoop的安装</h1><ol><li>安装jdk设置环境变量</li><li>安装hadoop应用程序</li><li>配置hadoop运行环境</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop-env.sh 配置java_home</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">core-site.xml </span><br><span class="line">- hadoop.tmp.dir hadoop的临时工作目录</span><br><span class="line">- dfs.name.dir 所有元数据的目录</span><br><span class="line">- fs.default.name 文件系统namenode访问地址</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs-site.xml</span><br><span class="line">- dfs.data.dir 文件系统的数据存放目录</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapred-site.xml</span><br><span class="line">- mapred.job.tracker 任务调度器该如何去访问</span><br></pre></td></tr></table></figure><p>最后对Hadoop的NameNode进行一个格式化操作</p><p>JPS查看当前运行的进程，查看Hadoop是否正常运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- JobTracker</span><br><span class="line">- DataNode</span><br><span class="line">- TaskTracker</span><br><span class="line">- NameNode</span><br><span class="line">- SecondaryNameNode</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><h2 id="HDFS的设计架构"><a href="#HDFS的设计架构" class="headerlink" title="HDFS的设计架构"></a>HDFS的设计架构</h2><ul><li>块（block）。HDFS的文件被分成块进行存储，默认大小64M，块是文件存储处理的逻辑单元。</li><li>NameNode。管理节点，存放文件元数据，元数据包括：<ul><li>文件与数据块的映射表</li><li>数据节点与数据块的映射表</li></ul></li><li>DataNode。DataNode是HDFS的工作节点，存放具体的数据块。</li></ul><h2 id="HDFS中数据管理策略"><a href="#HDFS中数据管理策略" class="headerlink" title="HDFS中数据管理策略"></a>HDFS中数据管理策略</h2><ul><li>数据块的放置：每个数据块3个副本，分布在两个机架内的三个节点上，保证硬件上的容错。</li><li>心跳检测：DataNode定期向NameNode发送心跳消息。</li><li>二级NameNode：定期同步元数据映射文件和修改日志，NameNode发生故障时，使用SecondaryNameNode</li></ul><h2 id="HDFS中文件读取流程"><a href="#HDFS中文件读取流程" class="headerlink" title="HDFS中文件读取流程"></a>HDFS中文件读取流程</h2><p>读文件</p><ul><li>客户端向NanmeNode发起请求（文件名，路径），NameNode返回客户端，这个文件包含哪些块，在哪些DataNode；</li><li>客户端直接去读取Block，进行组装。</li></ul><p>写文件</p><ul><li>客户端将文件拆分成块（block），之后通知NameNode；</li><li>NameNode找到一些可用的DataNode并返回给客户端；</li><li>客户端根据这些块信息进行写入Block；</li><li>写入一个块之后要进行流水线复制，即写完一个block之后通过一个复制管道复制到另一个DataNode，然后再复制到另外一个机器上的DataNode；</li><li>复制完成之后，更新NameNode的元数据；</li><li>写完一个block之后继续以上步骤写入下一个block。</li></ul><h2 id="HDFS的特点"><a href="#HDFS的特点" class="headerlink" title="HDFS的特点"></a>HDFS的特点</h2><ul><li>数据冗余，硬件容错；</li><li>流式是的数据访问；</li><li>适合存储大文件，小文件会使NameNode压力增大；</li><li>适合数据批量读写，吞吐量高，不适合做交互式应用，低延迟很难满足；</li><li>适合一次写入，多次读取，顺序读写，不支持多用户并发写相同文件。</li></ul><h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><h2 id="MapReduce的原理"><a href="#MapReduce的原理" class="headerlink" title="MapReduce的原理"></a>MapReduce的原理</h2><p>MapReduce的本质就是分而治之，就是将一个大任务拆分成多个小的子任务(Map)，多个任务节点进行并行执行之后，合并结果(Reduce)。</p><p>比如，通过日志分析，找到用户最常使用的功能。将日志按照时间进行拆分（Map过程），得到每个功能触发的次数，然后将每个任务的结果交换并进行合并（Reduce过程），排序之后得到总的功能使用统计情况。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大数据存储与处理技术的原理。<br>什么是Hadoop？<br>Hadoop的基本思想？<br>如何安装Hadoop？<br>Hadoop的重要组成部分：HDFS、MapReduce。<br>Hadoop的应用实例。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;谷歌大数据技术MapReduce、BigTable、GFS突破了存储容量、读写速率、计算效率的瓶颈，带来了革命性的变化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成本降低。能用家用PC计算机。&lt;/li&gt;
&lt;li&gt;软件容错硬件故障视为常态，通过软件保证高可靠性。&lt;/li&gt;
&lt;li&gt;简化并行分布式计算，无须控制节点同步和数据交换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是谷歌只发表了论文，没有公开源码，所以开发者模仿Google大数据技术，创造了一个开源的分布式存储和分布式计算平台&lt;code&gt;Hadoop&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Hadoop包括两个核心组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HDFS。分布式文件系统，实现海量数据的存储。&lt;/li&gt;
&lt;li&gt;MapReduce。并行处理框架，实现任务的分解和调度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hadoop优势：高扩展、低成本、成熟的生态圈&lt;/p&gt;
&lt;p&gt;常见的Hadoop工具包括：HIVE、HBASE、Zookeeper&lt;/p&gt;
&lt;h1 id=&quot;Hadoop的安装&quot;&gt;&lt;a href=&quot;#Hadoop的安装&quot; class=&quot;headerlink&quot; title=&quot;Hadoop的安装&quot;&gt;&lt;/a&gt;Hadoop的安装&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;安装jdk设置环境变量&lt;/li&gt;
&lt;li&gt;安装hadoop应用程序&lt;/li&gt;
&lt;li&gt;配置hadoop运行环境&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hadoop-env.sh 配置java_home&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;core-site.xml &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- hadoop.tmp.dir hadoop的临时工作目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- dfs.name.dir 所有元数据的目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- fs.default.name 文件系统namenode访问地址&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hdfs-site.xml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- dfs.data.dir 文件系统的数据存放目录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mapred-site.xml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- mapred.job.tracker 任务调度器该如何去访问&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后对Hadoop的NameNode进行一个格式化操作&lt;/p&gt;
&lt;p&gt;JPS查看当前运行的进程，查看Hadoop是否正常运行&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- JobTracker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- DataNode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- TaskTracker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- NameNode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- SecondaryNameNode&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程之美" scheme="http://jiangjiuwen.com/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="Hadoop" scheme="http://jiangjiuwen.com/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://jiangjiuwen.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>设计模式概览</title>
    <link href="http://jiangjiuwen.com/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/summary-of-design-pattern/"/>
    <id>http://jiangjiuwen.com/编程之美/summary-of-design-pattern/</id>
    <published>2017-10-01T14:41:57.000Z</published>
    <updated>2018-04-01T09:00:23.788Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式共分为三种类型，分别为：</p><ul><li>创建型。这一类设计模式主要<code>提供一种创建对象但是隐藏创建逻辑的方式</code>。比如单例模式、工厂模式。</li><li>结构型。这一类设计模式主要<code>关注类和对象的组合方式</code>。比如装饰者模式、适配器模式。</li><li>行为型。这一类设计模式主要<code>关注对象之间的通信方式</code>。比如状态模式、观察者模式、策略模式。</li></ul><p>设计模式的六大设计原则包括：</p><ul><li>开闭原则。<code>对扩展开放，对修改关闭</code>。即在程序进行扩展的时候，不去修改原有代码，实现一个热插拔的效果。为了达到这个效果，我们应该使用接口和抽象类。<code>实现开闭原则的关键是抽象化</code>。</li><li>里氏替换原则。<code>父类能够出现的地方，子类一定可以出现，即子类能够替换父类</code>。也就是说，只有当子类替换掉父类，而且程序功能不受影像，父类才能被复用，子类也能在父类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。</li><li>依赖倒置原则。依赖倒置原则是开闭原则的基础。具体表现为<code>针对接口编程，依赖于抽象而不是依赖于具体</code>。</li><li>接口隔离原则。<code>使用多个隔离的接口，而不是使用一个统一的接口</code>。为了降低类之间的依赖和耦合。</li><li>迪米特法则。最少知道原则，<code>一个实体应该尽可能少的和其他实体发生相互作用</code>，使得系统模块相互独立。</li><li>合成复用原则。<code>尽量使用合成、聚合的方式，而不是使用继承</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计模式共分为三种类型，分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型。这一类设计模式主要&lt;code&gt;提供一种创建对象但是隐藏创建逻辑的方式&lt;/code&gt;。比如单例模式、工厂模式。&lt;/li&gt;
&lt;li&gt;结构型。这一类设计模式主要&lt;code&gt;关注类和对象的组合方式&lt;/code&gt;。比
      
    
    </summary>
    
      <category term="编程之美" scheme="http://jiangjiuwen.com/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="设计模式" scheme="http://jiangjiuwen.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>从上海到武汉</title>
    <link href="http://jiangjiuwen.com/%E9%9A%8F%E7%AC%94/experience-in-wuhuan/"/>
    <id>http://jiangjiuwen.com/随笔/experience-in-wuhuan/</id>
    <published>2017-07-09T12:12:06.000Z</published>
    <updated>2018-04-01T09:00:23.787Z</updated>
    
    <content type="html"><![CDATA[<p>从上海到武汉，八百公里有余，而我心中产生的落差却远不止八百公里，无论是从环境、从人文、还是从其它各方面来讲，武汉都不是一个可以和上海相媲美的城市。</p><p>初次踏上武汉的土地，差点就想转身踏上高铁返回上海了，我以为我来到了乡下，到处挖坑修路，灰尘漫天，交通拥挤，再这样的环境下，人们是很难保持好心情好脾气的，好不容易打到一辆出租车，去往我租住的地方，一路上司机都会操着武汉方言对过往的车辆，尤其是前方车辆司机的家人送去“美好的祝福”。</p><p>要说武汉有什么是比上海好的话，房价算一个，毕竟二线城市，1400就能租到一个四十几平的一室一厅的还算比较新的房子，这在上海是不可能发生的。</p><p>也许是在江浙沪生活太久的缘故，已经习惯了清淡的口味，来到武汉，第一顿饭就是各种红油、辣椒之类的饭菜，实在是可怕，所以很快我就口腔溃疡，上火了。可是在小区周边找了很久都没有找到一家不那么重口味的餐馆，我发现不管什么菜，都会放很多油，地沟油不要钱的么？</p><p>关于武汉公交的可怕传说早已有所耳闻，我也做好了各种心理准备，然而当我真正体验过后，我觉得我还是too young，too simple，sometimes naive。人多就不说了，来了不到半个月就遇到了各种奇葩状况，第一天上班就遇到上班族跟司机吵起来了，理由是司机不开后门让他上车，两人各说各有理，僵持不下。第二个状况是公交车居然冒烟了，我惊呆了，更令我吃惊的是乘客们对此并不以为然，只是一边抱怨上班又要迟到了一边下车等待下一辆车。最令我惊掉下巴的是和朋友吃完晚饭坐夜班公交回家的途中，司机居然在毫无征兆的情况下停车，下去抽烟玩手机去了，留下一车的乘客在风中凌乱。至此我对武汉的公交绝望了，我决定考驾照，立刻，马上。</p><p>短短十来天的感受，却都是些负面情绪，可能跟我没有深入体验武汉这座城市有关，毕竟并没有去过太多的地方，希望一年以后，我能喜欢上这儿，至少不讨厌吧，反正来都来了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从上海到武汉，八百公里有余，而我心中产生的落差却远不止八百公里，无论是从环境、从人文、还是从其它各方面来讲，武汉都不是一个可以和上海相媲美的城市。&lt;/p&gt;
&lt;p&gt;初次踏上武汉的土地，差点就想转身踏上高铁返回上海了，我以为我来到了乡下，到处挖坑修路，灰尘漫天，交通拥挤，再这样
      
    
    </summary>
    
      <category term="随笔" scheme="http://jiangjiuwen.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="武汉" scheme="http://jiangjiuwen.com/tags/%E6%AD%A6%E6%B1%89/"/>
    
  </entry>
  
  <entry>
    <title>漫游CMEF</title>
    <link href="http://jiangjiuwen.com/%E9%9A%8F%E7%AC%94/cmef-2017/"/>
    <id>http://jiangjiuwen.com/随笔/cmef-2017/</id>
    <published>2017-05-15T11:29:21.000Z</published>
    <updated>2018-04-01T09:00:23.787Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xr526.com1.z0.glb.clouddn.com/cmef%202017/20170515_011802205_iOS.jpg" class="full-image"></p><p>今天是我第三次去看CMEF。</p><p>第一次是前年五月，当时刚参加工作不到一个月，啥也不懂，跟着同事就去了，纯粹就是看热闹。</p><p>第二次是去年四月，带着了解行业动态的目的去逛了一圈，发现友商的产品（软件及硬件）在颜值上实在不敢恭维，毕竟颜值即正义，幸亏我司向来走高大上路线。</p><p>这一次去主要是冲着我司直线加速器发布会，蛰伏四年终于亮相了，能够在将要离开之际看到自己参与了两年的产品正式发布，也算是一件值得欣慰的事情，虽然只做了一点微小的工作 😀</p><a id="more"></a><p><img src="http://7xr526.com1.z0.glb.clouddn.com/cmef%202017/20170515_014823073_iOS.jpg" alt=""></p><p><img src="http://7xr526.com1.z0.glb.clouddn.com/cmef%202017/20170515_014636972_iOS.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xr526.com1.z0.glb.clouddn.com/cmef%202017/20170515_011802205_iOS.jpg&quot; class=&quot;full-image&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天是我第三次去看CMEF。&lt;/p&gt;
&lt;p&gt;第一次是前年五月，当时刚参加工作不到一个月，啥也不懂，跟着同事就去了，纯粹就是看热闹。&lt;/p&gt;
&lt;p&gt;第二次是去年四月，带着了解行业动态的目的去逛了一圈，发现友商的产品（软件及硬件）在颜值上实在不敢恭维，毕竟颜值即正义，幸亏我司向来走高大上路线。&lt;/p&gt;
&lt;p&gt;这一次去主要是冲着我司直线加速器发布会，蛰伏四年终于亮相了，能够在将要离开之际看到自己参与了两年的产品正式发布，也算是一件值得欣慰的事情，虽然只做了一点微小的工作 😀&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://jiangjiuwen.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="CMEF" scheme="http://jiangjiuwen.com/tags/CMEF/"/>
    
      <category term="UIH" scheme="http://jiangjiuwen.com/tags/UIH/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://jiangjiuwen.com/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/singleton-pattern/"/>
    <id>http://jiangjiuwen.com/编程之美/singleton-pattern/</id>
    <published>2017-05-08T12:31:56.000Z</published>
    <updated>2018-04-01T09:00:23.786Z</updated>
    
    <content type="html"><![CDATA[<p>单利模式属于创建型模式，确保一个类只有一个实例，且提供一个访问它的全局访问点。主要是为了防止一个全局使用的类频繁地创建和销毁，影响性能浪费资源。</p><p>使用场景：log系统</p><p>单例模式具有如下特征</p><ul><li>单例类只能有一个实例</li><li>单例类必须自己创建自己的唯一实例</li><li>单例类必须给其他对象提供这一实例</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingletonPattern</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonPattern _instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonPattern</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonPattern <span class="title">GetInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _instance = <span class="keyword">new</span> SingletonPattern();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Hello Jiang"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单利模式属于创建型模式，确保一个类只有一个实例，且提供一个访问它的全局访问点。主要是为了防止一个全局使用的类频繁地创建和销毁，影响性能浪费资源。&lt;/p&gt;
&lt;p&gt;使用场景：log系统&lt;/p&gt;
&lt;p&gt;单例模式具有如下特征&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单例类只能有一个实例&lt;/li&gt;
      
    
    </summary>
    
      <category term="编程之美" scheme="http://jiangjiuwen.com/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="设计模式" scheme="http://jiangjiuwen.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="http://jiangjiuwen.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>我的数据库技术栈</title>
    <link href="http://jiangjiuwen.com/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/my-database-technology-stack/"/>
    <id>http://jiangjiuwen.com/编程之美/my-database-technology-stack/</id>
    <published>2017-05-01T06:06:21.000Z</published>
    <updated>2018-04-01T09:00:23.785Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章实际上是对我的数据库知识的一点总结。</p><p>下图是我在手机上用MindNode(强烈推荐Apple产品用户下载使用)画的一张脑图。</p><p><img src="http://7xr526.com1.z0.glb.clouddn.com/database%20technology%20stack/new%20image%20-%202fm40.jpg" class="full-image" title="Database Technology Stack"></p><h1 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">维基百科</a>如是说：</p><blockquote><p>数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。</p></blockquote><p>通俗的理解就是数据库是一个用于存储数据的仓库，用户可以通过增删改查等操作对仓库中的数据进行管理。<br><a id="more"></a></p><h1 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h1><p>目前数据库主要分为关系型数据库和非关系型数据库两大类。</p><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p>关系型数据库(RDBMS)是指采用关系模型来组织数据的数据库，其中的关系模式就是指二维表格模型，所以关系型数据库就是由多张二维表格以及表格之间的关联所组成的数据组织。</p><p>常见的关系型数据库主要有：MSSQL、MySQL、Oracle。</p><h2 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h2><p>非关系型数据库又叫做NoSQL(Not only SQL)，顾名思义，不仅仅是SQL，算得上是对关系型数据库的扩展吧。</p><p>常见的非关系型数据库有四大类：键值存储数据库、列存储数据库、文档型数据库、图形数据库。比如比较流行的MongoDB就是一种文档型数据库。</p><h2 id="RDBMS和NoSQL比较"><a href="#RDBMS和NoSQL比较" class="headerlink" title="RDBMS和NoSQL比较"></a>RDBMS和NoSQL比较</h2><ul><li>非关系型数据库简单易部署，而且基本都是开源软件，而关系型数据库则不易部署且价格昂贵</li><li>非关系型数据库查询速度更快。因为非关系型数据库的数据通常存储与缓存之中，而关系型数据库将数据存储在硬盘中</li><li>非关系型数据库数据存储格式多样化，比如键值对形式、文档形式、图片形式等，而关系型数据库只支持基础数据类型</li><li>非关系型数据库具有较好的扩展性，但是关系型数据库由于有太多的机制限制其扩展性</li><li>关系型数据库提供SQL语言的支持，但是非关系型数据库不支持</li><li>关系型数据库支持事务，而非关系型数据库不支持</li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是关系型数据库独有的特性，主要包括原子性、一致性、隔离性和持久性，简称ACID。</p><h2 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h2><p>原子性是指把一系列数据库操作语句作为一个原子来对待，即一个事务包含一系列操作语句，这些语句要么全部执行成功，要么某句失败后全部操作回滚，不存在部分执行成功，部分执行失败的可能。比如，执行从账户A向账户B转账100块的操作，结果是要么A账户减少100块且B账户增加100块，要么A账户金额不变且B账户金额不变，不存在A账户减少100块，而B账户金额不变的情况。</p><h2 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h2><p>一致性是指一个事务在开始前和开始后数据库的完整性约束没有改变。即一个事务执行前和执行后数据始终符合之前设置的约束，比如主外键关联、数据检查等始终保持不变。</p><h2 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性(Isolation)"></a>隔离性(Isolation)</h2><p>隔离性是指多个事务之间是不关联的相互独立的，一个事务在执行过程中不能访问到另一个事务执行过程中的数据。但是完全的隔离是不现实的，除非一次只执行一个事务，但是这样做的效率是不忍直视的。事务之间的相互影响主要有以下三种。</p><ul><li>脏读。即一个事务读取了另一个事务还未提交的数据，而这个数据有可能被回滚</li><li>不可重复度。即一个事务范围内两次相同的查询却返回了不同的数据，比如，事务第一次查询之后另一个事务在数据库中对该数据进行了修改，导致事务第二次查询的结果和第一次查询的结果不一致。</li><li>幻读。即一个事务A在更新表中数据的时候，另一个事务Bi新增了一条符合事务A修改条件的新数据，导致最后发现还有事务A没有更新的数据，就像幻觉一样。</li></ul><p>所以为了消除事务之间的相互影响，可以通过对数据库加锁的方式来隔离不同的事务，但是这样会导致查询效率降低。</p><h2 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性(Durability)"></a>持久性(Durability)</h2><p>持久性是指事务对数据进行的改变会持续保留在数据库中，不会随着事务的结束或关闭数据库等操作而回滚。</p><h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><p>为了建立冗余较小，结构合理的数据库，设计数据库时必须遵循一定的规范，在关系型数据库中，这种规则就叫做范式。在实际开发中使用的范式主要有三种。</p><h2 id="第一范式-NF1"><a href="#第一范式-NF1" class="headerlink" title="第一范式(NF1)"></a>第一范式(NF1)</h2><p>第一范式确保每列保持原子性。第一范式是数据库设计最基本的范式，如果表中所有字段都是不可再分解的原子值，就说明该数据库设计符合第一范式。例如，根据项目实际情况，可将地址拆分为省份、城市、区域、详细地址等字段，这样对地址中的某一部分操作就变得非常方便。</p><h2 id="第二范式-NF2"><a href="#第二范式-NF2" class="headerlink" title="第二范式(NF2)"></a>第二范式(NF2)</h2><p>第二范式确保表中的每列都和主键有关。即一张表只能存储一类数据，而不能将多种数据存在一张表中。比如订单信息和商品信息属于两类信息，应该分开建表存储，并通过关联表进行关联，而不是将订单信息和商品信息存储在一张表中。</p><h2 id="第三范式-NF3"><a href="#第三范式-NF3" class="headerlink" title="第三范式(NF3)"></a>第三范式(NF3)</h2><p>第三范式确保每列都和主键直接关联，而不是间接关联。第三范式和第二范式有点相似，不同之处在于将不同类信息通过主外键关系进行关联。</p><h1 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h1><h2 id="数据定义语言-DDL"><a href="#数据定义语言-DDL" class="headerlink" title="数据定义语言(DDL)"></a>数据定义语言(DDL)</h2><p>数据定义语言(Data Definition Language)用于对数据库或数据库表进行操作，比如<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code></p><h2 id="数据操作语言-DML"><a href="#数据操作语言-DML" class="headerlink" title="数据操作语言(DML)"></a>数据操作语言(DML)</h2><p>数据操作语言(Data Manipulation Language)用于对数据进行操作，比如<code>SELECT</code>、<code>INSERT INTO</code>、<code>UPDATE</code>、<code>DELETE</code></p><h2 id="数据控制语言-DCL"><a href="#数据控制语言-DCL" class="headerlink" title="数据控制语言(DCL)"></a>数据控制语言(DCL)</h2><p>数据控制语言(Data Control Language)用于设置或更改数据库用户或角色权限，比如<code>GRANT</code>、<code>DENY</code>、<code>REVOKE</code></p><h2 id="事务控制语言-TCL"><a href="#事务控制语言-TCL" class="headerlink" title="事务控制语言(TCL)"></a>事务控制语言(TCL)</h2><p>事务控制语言(Transact Control Language)用于控制事务的语言，比如<code>SAVEPOINT</code>、<code>ROLLBACK</code>、<code>COMMIT</code></p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引就是加快检索表中数据的方法。其原理类似于书籍的目录，即不需要扫描整个数据库都能快速找到所需的数据。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是虚表，是从一个或多个基本表中导出的表，视图对应的数据不进行实际存储，数据库只存储视图的定义，在对视图的数据进行操作时，系统根据视图的定义去操作与视图相关联的基本表。</p><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是一种特殊的存储过程。一般的存储过程是直接调用，而触发器主要是通过事件，比如增删改，进行触发而被执行，其在表中数据发生变化时自动强制执行。</p><p>常见的触发器有两种：AFTER(FOR) INSTEAD OF，用于INSERT、UPDATE、DELETE事件。</p><p>AFTER(FOR)表示执行代码后执行触发器</p><p>INSTEAD OF表示执行代码前，用已经写好的触发器代替你的操作。</p><blockquote><p>以上很多都只解释了定义，没有解释原理和举例，后续再写吧，毕竟这篇文章只是用来解释我画的那张脑图。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章实际上是对我的数据库知识的一点总结。&lt;/p&gt;
&lt;p&gt;下图是我在手机上用MindNode(强烈推荐Apple产品用户下载使用)画的一张脑图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr526.com1.z0.glb.clouddn.com/database%20technology%20stack/new%20image%20-%202fm40.jpg&quot; class=&quot;full-image&quot; title=&quot;Database Technology Stack&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是数据库&quot;&gt;&lt;a href=&quot;#什么是数据库&quot; class=&quot;headerlink&quot; title=&quot;什么是数据库&quot;&gt;&lt;/a&gt;什么是数据库&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科&lt;/a&gt;如是说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通俗的理解就是数据库是一个用于存储数据的仓库，用户可以通过增删改查等操作对仓库中的数据进行管理。&lt;br&gt;
    
    </summary>
    
      <category term="编程之美" scheme="http://jiangjiuwen.com/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据库" scheme="http://jiangjiuwen.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="技术栈" scheme="http://jiangjiuwen.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>my-trip-to-suzhou</title>
    <link href="http://jiangjiuwen.com/%E6%B8%B8%E8%AE%B0/my-trip-to-suzhou/"/>
    <id>http://jiangjiuwen.com/游记/my-trip-to-suzhou/</id>
    <published>2017-04-30T08:23:54.000Z</published>
    <updated>2018-05-04T09:27:01.151Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">苏州 · 拙政园</blockquote><br><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/suzhou/new%20image%20-%20gjzve.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/suzhou/new%20image%20-%20rsv16.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/suzhou/suzhou2.jpg" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/suzhou/new%20image%20-%201qh9e.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/suzhou/new%20image%20-%20f3190.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/suzhou/new%20image%20-%20yr6f7.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;苏州 · 拙政园&lt;/blockquote&gt;&lt;br&gt;&lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class
      
    
    </summary>
    
      <category term="游记" scheme="http://jiangjiuwen.com/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="旅游" scheme="http://jiangjiuwen.com/tags/%E6%97%85%E6%B8%B8/"/>
    
      <category term="苏州" scheme="http://jiangjiuwen.com/tags/%E8%8B%8F%E5%B7%9E/"/>
    
      <category term="拙政园" scheme="http://jiangjiuwen.com/tags/%E6%8B%99%E6%94%BF%E5%9B%AD/"/>
    
  </entry>
  
  <entry>
    <title>我所理解的REST</title>
    <link href="http://jiangjiuwen.com/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/what-is-rest/"/>
    <id>http://jiangjiuwen.com/编程之美/what-is-rest/</id>
    <published>2017-04-28T12:39:07.000Z</published>
    <updated>2018-04-01T09:00:23.784Z</updated>
    
    <content type="html"><![CDATA[<p>很多次在浏览技术社区的时候都会看到介绍REST或RESTful的文章，但我一次都没有点开过，所以我对这个术语感到既熟悉又陌生。今天又看到了一篇介绍REST的文章，一时没忍住就点开了，读完之后决定好好了解一下，几番Bing，收获如下。</p><h1 id="什么是REST"><a href="#什么是REST" class="headerlink" title="什么是REST"></a>什么是REST</h1><p>REST是<code>REpresentational State Transfer</code>的缩写，中文名又叫<code>表现层状态转移</code>，好吧，并不是很懂。搜索了一下才发现这个术语的主语Resource被省略了，REST的全称实际上叫做<code>Resource Representational State Transfer</code> ←_←</p><ul><li>Resource：网络资源。比如一个文本，一个视频，一幅图片等实体。</li><li>Representational：表现形式。比如XML、Binaray、Json、PNG等格式。</li><li>State Transfer：状态转移。即资源的状态发生改变，比如被修改或者被删除。</li></ul><p>所以，合起来就可以理解为资源在网络中通过某种表现形式进行状态的改变。用知乎大神<a href="https://www.zhihu.com/question/28557115/answer/41265890" target="_blank" rel="noopener">Ivony</a>的话说就是：用URL定位资源，用HTTP动词(GET、POST、DELETE、PUT)描述操作。</p><a id="more"></a><h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h2><p>资源的状态转移，就是通过HTTP动词来描述的，即GET、POST、PUT、DELETE</p><ul><li>GET(SELECT)：从服务器取获取资源（一项或多项）</li><li>POST(CREATE)：在服务器新建一个资源</li><li>PUT(UPDATE)：在服务器更新资源（客户端提供改变后的完整资源）</li><li>PATCH(UPDATE)：在服务器更新资源（客户端提供改变的属性）</li><li>DELETE(DELETE)：从服务器删除资源</li></ul><h2 id="REST和RESTful-API的关系"><a href="#REST和RESTful-API的关系" class="headerlink" title="REST和RESTful API的关系"></a>REST和RESTful API的关系</h2><p>REST是一种抽象的设计风格，他定义了一些接口设计原则，即只要设计接口的时候遵循REST原则，就可以说这个接口具有REST风格。而RESTful API则是指按照REST设计原则实现的具体的网络接口。</p><h1 id="RESTful架构的优势"><a href="#RESTful架构的优势" class="headerlink" title="RESTful架构的优势"></a>RESTful架构的优势</h1><p>早期的WEB都是前后端杂糅在一起，但是随着互联网的发展以及各种类型的终端的诞生，以前的设计风格很难适应所有的终端的要求。RESTful的优势就在于它可以在Server端制定一套统一的接口，来为所有的终端提供服务。</p><p>一个典型的RESTful架构如下图所示。</p><p><img src="http://7xr526.com1.z0.glb.clouddn.com/restfull.jpg" alt="RESTful架构"></p><h1 id="RESTful架构设计原则"><a href="#RESTful架构设计原则" class="headerlink" title="RESTful架构设计原则"></a>RESTful架构设计原则</h1><p>如何设计一个优秀的RESTful架构是一件十分困难的事情，不是看几篇文章就能实现的，需要经过长期的经验积累，由于我还并没有相关经验，这部分内容就暂且按下不表了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多次在浏览技术社区的时候都会看到介绍REST或RESTful的文章，但我一次都没有点开过，所以我对这个术语感到既熟悉又陌生。今天又看到了一篇介绍REST的文章，一时没忍住就点开了，读完之后决定好好了解一下，几番Bing，收获如下。&lt;/p&gt;
&lt;h1 id=&quot;什么是REST&quot;&gt;&lt;a href=&quot;#什么是REST&quot; class=&quot;headerlink&quot; title=&quot;什么是REST&quot;&gt;&lt;/a&gt;什么是REST&lt;/h1&gt;&lt;p&gt;REST是&lt;code&gt;REpresentational State Transfer&lt;/code&gt;的缩写，中文名又叫&lt;code&gt;表现层状态转移&lt;/code&gt;，好吧，并不是很懂。搜索了一下才发现这个术语的主语Resource被省略了，REST的全称实际上叫做&lt;code&gt;Resource Representational State Transfer&lt;/code&gt; ←_←&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Resource：网络资源。比如一个文本，一个视频，一幅图片等实体。&lt;/li&gt;
&lt;li&gt;Representational：表现形式。比如XML、Binaray、Json、PNG等格式。&lt;/li&gt;
&lt;li&gt;State Transfer：状态转移。即资源的状态发生改变，比如被修改或者被删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，合起来就可以理解为资源在网络中通过某种表现形式进行状态的改变。用知乎大神&lt;a href=&quot;https://www.zhihu.com/question/28557115/answer/41265890&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ivony
&lt;/a&gt;的话说就是：用URL定位资源，用HTTP动词(GET、POST、DELETE、PUT)描述操作。&lt;/p&gt;
    
    </summary>
    
      <category term="编程之美" scheme="http://jiangjiuwen.com/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="REST" scheme="http://jiangjiuwen.com/tags/REST/"/>
    
      <category term="RESTful" scheme="http://jiangjiuwen.com/tags/RESTful/"/>
    
  </entry>
  
  <entry>
    <title>travel-to-huangshan</title>
    <link href="http://jiangjiuwen.com/%E6%B8%B8%E8%AE%B0/test-group-picture/"/>
    <id>http://jiangjiuwen.com/游记/test-group-picture/</id>
    <published>2017-04-23T10:34:40.000Z</published>
    <updated>2018-05-04T09:26:58.117Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">黄山归来不看山</blockquote><br><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/SDC10279.JPG" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/IMG_0710.JPG" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/DSC03797.JPG" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="http://7xr526.com1.z0.glb.clouddn.com/DSC03510.JPG" alt=""></div></div><div class="group-picture-row"></div></div></div></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;黄山归来不看山&lt;/blockquote&gt;&lt;br&gt;&lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=
      
    
    </summary>
    
      <category term="游记" scheme="http://jiangjiuwen.com/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="安徽" scheme="http://jiangjiuwen.com/tags/%E5%AE%89%E5%BE%BD/"/>
    
      <category term="黄山" scheme="http://jiangjiuwen.com/tags/%E9%BB%84%E5%B1%B1/"/>
    
      <category term="旅游" scheme="http://jiangjiuwen.com/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>如何在GitHub上构建并部署Hexo博客</title>
    <link href="http://jiangjiuwen.com/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/how-to-deploy-hexo-blog-on-github/"/>
    <id>http://jiangjiuwen.com/编程之美/how-to-deploy-hexo-blog-on-github/</id>
    <published>2017-04-22T12:45:12.000Z</published>
    <updated>2018-04-01T09:00:23.782Z</updated>
    
    <content type="html"><![CDATA[<p>当你在搜索引擎中同时输入<code>Hexo</code>、<code>GitHub</code>等关键字，浏览器会立马展现无数教你利用GitHub和Hexo构建免费个人博客的教程，所以这里不再对此赘述，本文旨在记录我这两天搭建博客的过程中遇到的问题以及解决办法。</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>首先当然是安装Node.js，Hexo以及Git(因为要部署博客和托管源码到GitHub)，几条命令就解决了，轻松加愉快。</p><p>以下是Hexo官网提供的几条最基本的使用命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo-cli -g</span><br><span class="line"><span class="meta">$</span> hexo init blog</span><br><span class="line"><span class="meta">$</span> cd blog</span><br><span class="line"><span class="meta">$</span> npm install</span><br><span class="line"><span class="meta">$</span> hexo server</span><br></pre></td></tr></table></figure><p>值得注意的是，如果是从远程仓库<code>pull</code>下来的源码，则不需要初始化Hexo文件夹，只需要执行第四行<code>install</code>命令就够了，因为远程仓库中的文件是已经初始化过的，如果再次<code>init</code>会使自定义配置文件被默认文件覆盖。<br><a id="more"></a></p><h1 id="绑定独立域名"><a href="#绑定独立域名" class="headerlink" title="绑定独立域名"></a>绑定独立域名</h1><p>当我们在创建仓库的时候GitHub就自动给我们生成了一个二级域名，比如<code>jiangjiuwen.github.io</code>，但是，作为个人博客，拥有一个自定义的独立域名将是一件多么炫酷的事情(购买顶级域名，这是唯一一件需要花钱的事情)。</p><h2 id="修改DNS"><a href="#修改DNS" class="headerlink" title="修改DNS"></a>修改DNS</h2><p>到域名管理面板增加两条A记录和一条CNAME，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A @ 192.30.252.153</span><br><span class="line">A @ 192.30.252.154 </span><br><span class="line">CNAME www jiangjiuwen.github.io</span><br></pre></td></tr></table></figure><h2 id="创建CNAME文件-无后缀"><a href="#创建CNAME文件-无后缀" class="headerlink" title="创建CNAME文件(无后缀)"></a>创建CNAME文件(无后缀)</h2><p>该文件里面有且仅有一行文本(你的独立域名，比如<code>jiangjiuwen.com</code>，没有<code>http</code>前缀)，需要一同被部署到GitHub。那么问题来了，当我第二次部署的时候，这个文件不见了，此时独立域名失效，其实这是因为每次部署都会更新整个仓库，而CNAME文件是用户手动添加的，所以被删除之后不会自动生成。</p><p>为了解决这个问题，只需要将CNAME文件放入<code>blog/source</code>文件夹下，然后再部署，此时CNAME文件就会随博客一起部署了，同理，其他由用户手动创建并需要被部署的文件都需要放在该文件夹下。</p><h1 id="多设备协同工作"><a href="#多设备协同工作" class="headerlink" title="多设备协同工作"></a>多设备协同工作</h1><p>通常我们只会在一台电脑上工作，但是，有时候我们也会需要在另一台电脑上写工作的情况，如果重新配置环境，就无法在当前博客版本上生成博客文件，这是无法接受的。</p><p>因此，我在把博客部署到Repo的<code>master</code>分支的时候，同时会把源代码一并<code>push</code>到另外一个branch上(比如本博客的<code>src</code>分支)，这样当我们在另外一台电脑上配置环境的时候只需要<code>pull</code> <code>src</code>分支就可以在最新的版本上继续工作了，部署之后将修改的内容一并<code>push</code>到分支上，这样回到主工作电脑上就可以将最新的修改<code>pull</code>到本地继续工作。</p><h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><p>搭建博客的过程中学会了很多命令，包括一些常用git命令和hexo命令，避免忘记，在此记录一下。</p><h2 id="常用Git命令"><a href="#常用Git命令" class="headerlink" title="常用Git命令"></a>常用Git命令</h2><p>连接远程服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git remote add origin git@github.com:jiangjiuwen/jiangjiuwen.github.io.git</span><br></pre></td></tr></table></figure><p>从服务器获取src分支代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git pull origin src</span><br></pre></td></tr></table></figure><p>检查当前分支状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git status</span><br></pre></td></tr></table></figure><p>将当前所有修改管理起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git add .</span><br></pre></td></tr></table></figure><p>提交本地修改到本地仓库的当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git commit -m 'Greeting from windows 10'</span><br></pre></td></tr></table></figure><p>提交本地代码到服务器src分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git push origin src</span><br></pre></td></tr></table></figure><p>切换到src分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout -q src</span><br></pre></td></tr></table></figure><p>合并分支(当前处于src分支，要把master分支合并过来)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git merge master</span><br></pre></td></tr></table></figure><p>还有其他常用命令暂时没用到或者还没学会 :-(</p><h2 id="常用Hexo命令"><a href="#常用Hexo命令" class="headerlink" title="常用Hexo命令"></a>常用Hexo命令</h2><p>安装git deployer插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>清理环境(删除public文件夹)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo clean</span><br></pre></td></tr></table></figure><p>启动本地服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo server</span><br></pre></td></tr></table></figure><p>部署博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo g -d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你在搜索引擎中同时输入&lt;code&gt;Hexo&lt;/code&gt;、&lt;code&gt;GitHub&lt;/code&gt;等关键字，浏览器会立马展现无数教你利用GitHub和Hexo构建免费个人博客的教程，所以这里不再对此赘述，本文旨在记录我这两天搭建博客的过程中遇到的问题以及解决办法。&lt;/p&gt;
&lt;h1 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h1&gt;&lt;p&gt;首先当然是安装Node.js，Hexo以及Git(因为要部署博客和托管源码到GitHub)，几条命令就解决了，轻松加愉快。&lt;/p&gt;
&lt;p&gt;以下是Hexo官网提供的几条最基本的使用命令。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; npm install hexo-cli -g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; hexo init blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; cd blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; npm install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;值得注意的是，如果是从远程仓库&lt;code&gt;pull&lt;/code&gt;下来的源码，则不需要初始化Hexo文件夹，只需要执行第四行&lt;code&gt;install&lt;/code&gt;命令就够了，因为远程仓库中的文件是已经初始化过的，如果再次&lt;code&gt;init&lt;/code&gt;会使自定义配置文件被默认文件覆盖。&lt;br&gt;
    
    </summary>
    
      <category term="编程之美" scheme="http://jiangjiuwen.com/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="Hexo" scheme="http://jiangjiuwen.com/tags/Hexo/"/>
    
      <category term="GitHub" scheme="http://jiangjiuwen.com/tags/GitHub/"/>
    
  </entry>
  
</feed>
